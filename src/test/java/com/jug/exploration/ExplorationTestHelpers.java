package com.jug.exploration;

import com.jug.MoMA;
import org.apache.commons.lang.NotImplementedException;
import org.jetbrains.annotations.NotNull;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import static com.jug.util.io.FileUtils.*;
import static java.util.Objects.isNull;

/**
 * This class provides adapter methods to enable testing MoMA from within test-code. This includes an adapter to start
 * MoMA with command line arguments from test-code.
 */
public class ExplorationTestHelpers {
    /**
     * Method to start MoMA with command-line arguments from test-code.
     * @param headless start MoMA in headless mode, if true; corresponds to command line argument -headless
     * @param inputPath input path; corresponds to command line argument -i
     * @param outputPath output path; corresponds to command line argument -o
     * @param tmin starting frame of the time range to analyze; corresponds to command line argument -tmin
     * @param tmax stop frame of the time range to analyze; corresponds to command line argument -tmax
     * @param deleteProbabilityMaps controls whether the probability map (which are generated by MoMA) should be deleted before starting MoMA; this is useful to force MoMA to generate the probability map on start; this is not a command line option, but for convenience during testing
     */
    public static void startMoma(boolean headless, String inputPath, String outputPath, Integer tmin, Integer tmax, boolean deleteProbabilityMaps) {
        startMoma(headless, inputPath, outputPath, tmin, tmax, deleteProbabilityMaps, null);
    }

    public static <T> void addToArgsIfNotNull(T argVal, String argName, List<String> args) {
        if (!isNull(argVal)) {
            args.add("-" + argName);
            args.add(argVal.toString());
        }
    }

    /**
     * Method to start MoMA with command-line arguments from test-code.
     * @param headless start MoMA in headless mode, if true; corresponds to command line argument -headless
     * @param inputPath input path; corresponds to command line argument -i
     * @param outputPath output path; corresponds to command line argument -o
     * @param tmin starting frame of the time range to analyze; corresponds to command line argument -tmin
     * @param tmax stop frame of the time range to analyze; corresponds to command line argument -tmax
     * @param deleteProbabilityMaps controls whether the probability map (which are generated by MoMA) should be deleted before starting MoMA; this is useful to force MoMA to generate the probability map on start; this is not a command line option, but for convenience during testing
     * @param additionalArgs additional command line arguments
     */
    public static void startMoma(boolean headless, String inputPath, String outputPath, Integer tmin, Integer tmax, boolean deleteProbabilityMaps, String[] additionalArgs) {
        if (deleteProbabilityMaps) {
            removeProbabilityMaps(Paths.get(inputPath));
        }

        List<String> args = new ArrayList<>();
        addToArgsIfNotNull(inputPath, "i", args);
        addToArgsIfNotNull(outputPath, "o", args);
        addToArgsIfNotNull(tmin, "tmin", args);
        addToArgsIfNotNull(tmax, "tmax", args);

        if (additionalArgs != null) {
            Collections.addAll(args, additionalArgs);
        }

        if (headless) {
            Collections.addAll(args, "-headless");
        }

        MoMA.main(args.toArray(new String[0]));
    }

    /**
     * Delete preexisting probability maps. During testing, we often want to test the generation
     * of the probability maps, which are cached to disk and loaded, if they exist for a given model.
     * This function removes those cached files to always run the U-Net preprocessing.
     *
     * @param path
     */
    private static void removeProbabilityMaps(Path path) {
        File parentFolder = new File(path.toFile().getParent());
        List<Path> matchingFiles = getMatchingFilesInDirectory(parentFolder.toPath(), "*__model_*.tif*");
        deleteFiles(matchingFiles);
    }

    /**
     * Get the name of the method that is calling this method. This method uses the idea presented here:
     * https://www.baeldung.com/java-name-of-executing-method
     *
     * @return
     */
    public static String getMethodName() {
        StackTraceElement[] stackTrace = Thread.currentThread()
                .getStackTrace();
        String name = stackTrace[2].getMethodName();
        return name;
    }

    /**
     * Compare text files line-by-line with option to skip the first user-defined number of lines.
     *
     * @param path1
     * @param path2
     * @return
     * @throws IOException
     */
    public static long compareTextFilesByLine(Path path1,
                                              Path path2,
                                              int numberOfLinesToSkip,
                                              List<String> ignoreStrings,
                                              boolean sortLinesAlphabetically) throws IOException {
        List<String> linesFromFile1 = readFileToStringList(path1, numberOfLinesToSkip);
        List<String> linesFromFile2 = readFileToStringList(path2, numberOfLinesToSkip);

        linesFromFile1 = removeLinesContaining(ignoreStrings, linesFromFile1);
        linesFromFile2 = removeLinesContaining(ignoreStrings, linesFromFile2);

        List<String> finalLinesFromFile2 = linesFromFile2;
//        boolean val = linesFromFile1.stream().anyMatch(line1 -> finalLinesFromFile.stream().anyMatch(line2 -> line2.equals(line1)));
        List<String> unmatchedLines = linesFromFile1.stream().filter(
                line1 -> !finalLinesFromFile2.stream().anyMatch(line2 -> line2.equals(line1))
        ).collect(Collectors.toList());
//        return val;

        if(sortLinesAlphabetically) {
            Collections.sort(linesFromFile1);
            Collections.sort(linesFromFile2);
        }

        throw new NotImplementedException();

//        try (BufferedReader bf1 = Files.newBufferedReader(path1);
//             BufferedReader bf2 = Files.newBufferedReader(path2)) {
//
//            long lineNumber = 1;
//            String line1 = "", line2 = "";
//            while ((line1 = bf1.readLine()) != null) {
//                line2 = bf2.readLine();
//                if (lineNumber > numberOfLinesToSkip & (line2 == null || !line1.equals(line2))) {
//                    return lineNumber;
//                }
//                lineNumber++;
//            }
//            if (bf2.readLine() == null) {
//                return -1;
//            }
//            else {
//                return lineNumber;
//            }
//        }
    }

    @NotNull
    private static List<String> removeLinesContaining(List<String> ignoreStrings, List<String> lines) {
        lines = lines.stream().filter(
                line -> !ignoreStrings.stream().anyMatch(string -> line.contains(string))
        ).collect(Collectors.toList());
        return lines;
    }

    private static List<String> readFileToStringList(Path path1, int numberOfLinesToSkip) throws IOException {
        try (BufferedReader bf1 = Files.newBufferedReader(path1)) {
            ArrayList<String> linesFile1 = new ArrayList<>();
            String line1;
            long lineNumber = 0;
            while ((line1 = bf1.readLine()) != null) {
                if (lineNumber >= numberOfLinesToSkip) {
                    linesFile1.add(line1);
                }
                lineNumber++;
            }
            return linesFile1;
        }
    }
}
